#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef int TreeElement;

// 트리 노드 구조체 (폴더 1개)
typedef struct TreeNode {
    TreeElement data;           // 노드의 용량
    struct TreeNode* left;      // 왼쪽 자식
    struct TreeNode* right;     // 오른쪽 자식
} TreeNode;

// 이진 트리 구조체
typedef struct {
    TreeNode* root;             // 루트 노드
} BinaryTree;

// 트리 초기화
void init_tree(BinaryTree* tree) {
    tree->root = NULL;
}

// 트리가 비어있는지 확인
int is_empty_tree(BinaryTree* tree) {
    return tree->root == NULL;
}

// 새 노드 생성
TreeNode* create_tree_node(TreeElement val, TreeNode* l, TreeNode* r) {
    TreeNode* root = (TreeNode*)malloc(sizeof(TreeNode));
    root->data = val;
    root->left = l;
    root->right = r;
    return root;
}

/**
 * @brief 폴더(노드)의 총 용량을 계산 (후위 순회)
 * @param subtree 현재 노드
 * @return 현재 노드와 모든 하위 노드의 용량 합
 */
int calc_size(TreeNode* subtree) {
    // 기본 단계: 노드가 없으면 0 반환
    if (subtree == NULL) {
        return 0;
    }

    // 재귀 단계: 왼쪽, 오른쪽 자식의 용량 계산
    int left_size = calc_size(subtree->left);
    int right_size = calc_size(subtree->right);

    // 현재 노드 용량 + 왼쪽 + 오른쪽
    return (subtree->data + left_size + right_size);
}

int main() {
    BinaryTree* tree = (BinaryTree*)malloc(sizeof(BinaryTree));
    init_tree(tree);

    int N;
    scanf("%d\n", &N);

    // 노드 배열 생성 및 메모리 할당
    TreeNode** node = (TreeNode**)malloc(sizeof(TreeNode*) * N);
    for (int i = 0; i < N; i++) 
        node[i] = (TreeNode*)malloc(sizeof(TreeNode));

    // 노드 정보 입력 및 연결
    for (int i = 0; i < N; i++) {
        TreeNode *tmp, *l_node, *r_node;
        int root_data, left_id, right_id;

        scanf("%d %d %d", &root_data, &left_id, &right_id);

        // 자식 노드 설정 (-1이면 NULL)
        l_node = left_id == -1 ? NULL : node[left_id];
        r_node = right_id == -1 ? NULL : node[right_id];

        // 노드 데이터 설정
        node[i]->data = root_data;
        node[i]->left = l_node;
        node[i]->right = r_node;
    }
    
    tree->root = node[0];

    printf("폴더 용량 = %d KB\n", calc_size(tree->root));

    // 메모리 해제
    for (int i = 0; i < N; i++) free(node[i]);
    free(node);
    free(tree);

    return 0;
}
