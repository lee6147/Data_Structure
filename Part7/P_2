#include <stdio.h> // C언어 표준 입출력 라이브러리 (printf, scanf 등을 쓰기 위해)
#include <stdlib.h> // C언어 표준 라이브러리 (malloc, free 등 메모리 할당을 위해)
#include <string.h> // C언어 문자열 라이브러리 (지금은 사용되지 않지만, 보통 넣어줍니다)

// 트리에 저장될 데이터(파일/폴더 용량)가 정수(int)라고 알려줍니다.
typedef int TreeElement; 

// 'TreeNode' 라는 이름의 '설계도'를 만듭니다. (폴더 1개)
typedef struct TreeNode {
    TreeElement data; // 폴더(노드) 자체의 용량 (파일 크기)
    struct TreeNode* left; // 왼쪽 자식 폴더를 가리키는 '포인터(화살표)'
    struct TreeNode* right; // 오른쪽 자식 폴더를 가리키는 '포인터(화살표)'
} TreeNode;

// 'BinaryTree' 라는 이름의 '설계도'를 만듭니다. (전체 폴더 시스템 관리자)
typedef struct {
    TreeNode* root; // '최상위(루트) 폴더'를 가리키는 '포인터(화살표)'
} BinaryTree;

// 트리 관리자를 초기화하는 함수
void init_tree(BinaryTree* tree) { 
    // 루트 폴더가 없다고(NULL) 설정해서 빈 트리로 만듭니다.
    tree->root = NULL; 
}

// 트리가 비어있는지 확인하는 함수
int is_empty_tree(BinaryTree* tree) { 
    // 루트 폴더가 없으면(NULL) 비어있는 것입니다.
    return tree->root == NULL; 
}

// 새 '폴더(노드)'를 만드는 함수
TreeNode* create_tree_node(TreeElement val, TreeNode* l, TreeNode* r) {
    // 1. 컴퓨터에게 새 노드를 만들 메모리(공간)를 달라고 요청(malloc)합니다.
    TreeNode* root = (TreeNode*)malloc(sizeof(TreeNode));
    
    // 2. 새 노드에 값을 채워넣습니다.
    root->data = val;  // 파일 용량(data)
    root->left = l;   // 왼쪽 자식 폴더(left)
    root->right = r;  // 오른쪽 자식 폴더(right)

    // 3. 방금 만든 새 노드(폴더)를 반환합니다.
    return root;
}

/**
 * @brief 폴더(노드)의 총 용량을 계산하는 함수 (가장 중요한 부분!)
 * @param subtree 현재 용량을 계산할 폴더(노드)
 * @return 이 폴더와 모든 하위 폴더들의 용량 총합 (KB)
 * * 이 함수는 '후위 순회' 방식을 사용합니다. (왼쪽 -> 오른쪽 -> 나)
 * (PDF '8.트리.pdf'의 Page 61, 'calc_dir_size' 함수 참고) [cite_start][cite: 2484]
 */
int calc_size(TreeNode* subtree) {
    // 이 함수는 '재귀(recursion)'라는 기술을 사용해요.
    // "내가 내 일을 하기 위해, 나와 똑같이 생긴 작은 버전의 나(자식)에게 일을 시키는 것"과 같아요.
    
    // 1. 재귀 호출의 '기본 단계(멈추는 조건)'
    if (subtree == NULL) { 
        // 만약 확인하려는 폴더(subtree)가 존재하지 않으면 (즉, NULL이면)
        // 용량은 0 KB 입니다. 여기서 함수가 멈추고 0을 돌려줍니다.
[cite_start]        return 0; [cite: 2486]
    }
    
    // 2. '재귀 단계' (스스로를 다시 호출하는 부분)
    // 현재 폴더의 총용량을 알기 위해, 먼저 자식 폴더들에게 물어봅니다.
    
    // (L: Left) 왼쪽 자식 폴더의 총용량을 계산해 오라고 'calc_size' 함수를 또 호출합니다.
[cite_start]    int left_size = calc_size(subtree->left); [cite: 2487]

    // (R: Right) 오른쪽 자식 폴더의 총용량을 계산해 오라고 'calc_size' 함수를 또 호출합니다.
[cite_start]    int right_size = calc_size(subtree->right); [cite: 2488]

    // 3. (V: Visit) '나'의 용량을 계산할 차례입니다.
    //    여기까지 왔다는 건, 내 모든 자식 폴더들이 자기 용량 계산을 다 끝내서
    //    left_size 와 right_size 에 그 값을 알려줬다는 뜻입니다.
    
    // 나의 총용량 = (나의 파일 용량) + (왼쪽 폴더 총용량) + (오른쪽 폴더 총용량)
[cite_start]    return (subtree->data + left_size + right_size); [cite: 2488]
}

// 프로그램의 시작점
int main() {
    // 트리 관리자(BinaryTree)를 위한 메모리를 컴퓨터에게 요청(malloc)합니다.
    BinaryTree* tree = (BinaryTree*)malloc(sizeof(BinaryTree));
    init_tree(tree);  // 트리를 '빈 트리'로 초기화합니다.

    int N; // 노드(폴더)의 총 개수를 저장할 변수
    scanf("%d\n", &N);  // 사용자에게 총 개수(N)를 입력받습니다.

    // '포인터 배열'을 만듭니다. 이것은 N개의 폴더(노드)들을
    // 0번, 1번, 2번... 인덱스로 쉽게 찾아갈 수 있게 도와주는 '목록'입니다.
    TreeNode** node = (TreeNode**)malloc(sizeof(TreeNode*) * N);
    // 목록(node)의 각 칸마다 실제 노드가 들어갈 메모리를 미리 할당해둡니다.
    for (int i = 0; i < N; i++) node[i] = (TreeNode*)malloc(sizeof(TreeNode));

    // N번 반복하면서 각 폴더(노드)의 정보를 입력받습니다.
    for (int i = 0; i < N; i++) {
        TreeNode *tmp, *l_node, *r_node; // 임시 변수들
        int root_data, left_id, right_id; // 입력받을 값들 (용량, 왼쪽ID, 오른쪽ID)

        // 예: 0 1 2 (용량 0, 왼쪽 자식 1, 오른쪽 자식 2)
        // 예: 50 -1 -1 (용량 50, 왼쪽 자식 없음, 오른쪽 자식 없음)
        scanf("%d %d %d", &root_data, &left_id, &right_id);

        // 왼쪽 자식 설정:
        // ID가 -1이면 '자식 없음(NULL)'
        // ID가 1이면, 위에서 만든 '목록(node)'의 1번 칸(node[1])을 가리키게 합니다.
        l_node = left_id == -1 ? NULL : node[left_id];

        // 오른쪽 자식도 똑같이 설정합니다.
        r_node = right_id == -1 ? NULL : node[right_id];
        
        // (이 부분은 PDF 예제와 조금 다릅니다. PDF 예제(page 61)는
        //  노드를 미리 다 만들어두고 시작하지만, 이 코드는 main 함수에서
        //  노드 정보를 입력받아 연결합니다. 로직은 동일합니다.)
        
        // '목록'에 있는 i번째 노드에 방금 입력받은 정보(용량, 자식 링크)를 채워넣습니다.
        node[i]->data = root_data;
        node[i]->left = l_node;
        node[i]->right = r_node;
    }
    // 모든 폴더(노드) 연결이 끝났습니다.
    // 0번 노드를 '최상위(루트) 폴더'로 설정합니다.
    tree->root = node[0];

    // 'calc_size' 함수를 루트 폴더(tree->root)부터 시작하라고 호출하고,
    // 반환된 최종 용량을 출력합니다.
    printf("폴더 용량 = %d KB\n", calc_size(tree->root));

    // --- 메모리 정리 ---
    // N개의 노드 메모리를 하나씩 해제합니다.
    for (int i = 0; i < N; i++) free(node[i]);
    // 노드 '목록(포인터 배열)' 자체의 메모리를 해제합니다.
    free(node);
    // 트리 '관리자'의 메모리를 해제합니다.
    free(tree);

    return 0; // 프로그램 종료
}
