#include <stdio.h>    // 'printf' (화면에 글자 출력), 'scanf' (키보드 입력 받기) 같은 기본 기능을 쓰기 위해 필요한 파일이야.
#include <stdlib.h>   // 'malloc' (메모리 빌리기), 'free' (메모리 반납) 같은 메모리 관리 기능을 쓰기 위해 필요해.
#include <string.h>   // (이 코드에서는 사용되지 않았지만) 보통 'strcpy' 같은 문자열 복사 함수를 쓸 때 필요해.

// 트리에 저장할 데이터의 종류(Type)가 'int' (정수)라고 정하고,
// 앞으로 'TreeElement'라는 별명으로 부를게.
typedef int TreeElement;

// '트리 노드' (폴더 1개라고 생각하면 쉬워)의 설계도야.
typedef struct TreeNode {
    TreeElement data;           // 1. 노드(폴더) 자체에 저장된 데이터 (여기서는 '용량'을 뜻하는 숫자)
    struct TreeNode* left;      // 2. 왼쪽 자식 노드(하위 폴더)를 가리키는 포인터(주소)
    struct TreeNode* right;     // 3. 오른쪽 자식 노드(하위 폴더)를 가리키는 포인터(주소)
} TreeNode;

// '이진 트리' 전체를 관리하기 위한 구조체야.
typedef struct {
    TreeNode* root;             // 트리의 가장 꼭대기, 즉 '뿌리(root)' 노드의 주소를 저장하는 포인터.
} BinaryTree;

// 트리를 처음 만들 때 '초기화'해주는 함수.
void init_tree(BinaryTree* tree) {
    tree->root = NULL; // 처음엔 트리에 아무것도 없으니까, root는 '없음'(NULL)을 가리키게 해.
}

// 트리가 비어있는지 확인하는 함수.
int is_empty_tree(BinaryTree* tree) {
    return tree->root == NULL; // root가 NULL이면 비어있는 거야 (맞으면 1, 아니면 0을 반환).
}

// 새로운 노드(폴더)를 하나 만드는 함수.
// (이 프로그램의 main 함수에서는 직접 쓰이진 않았어.)
TreeNode* create_tree_node(TreeElement val, TreeNode* l, TreeNode* r) {
    // 1. 새 노드를 저장할 만큼의 메모리 공간을 운영체제로부터 빌려와.
    TreeNode* root = (TreeNode*)malloc(sizeof(TreeNode));
    // 2. 빌려온 공간에 데이터와 자식 노드들의 주소를 저장해.
    root->data = val;
    root->left = l;
    root->right = r;
    // 3. 완성된 새 노드의 주소(포인터)를 반환해.
    return root;
}

/**
 * @brief 폴더(노드)의 총 용량을 계산하는 함수 (후위 순회 방식)
 * (8.트리.pdf, 61페이지 'calc_dir_size' 함수 참고)
 * @param subtree 현재 방문 중인 노드(폴더)
 * @return 현재 노드와 그 아래 모든 자식 노드들의 용량 총합
 */
int calc_size(TreeNode* subtree) {
    // 1. (재귀의 '기본 단계') 만약 방문한 노드가 NULL이면 (즉, 폴더가 없으면)
    //    더 이상 계산할 게 없으니 용량은 0이야.
    if (subtree == NULL) {
        return 0;
    }

    // 2. (재귀의 '유도 단계') 현재 노드가 있다면,
    //    먼저 왼쪽 자식 폴더로 똑같은 'calc_size' 함수를 실행시켜서 총 용량을 계산해 오라고 해. (재귀 호출)
    int left_size = calc_size(subtree->left);
    //    그 다음, 오른쪽 자식 폴더로 똑같이 'calc_size' 함수를 실행시켜 총 용량을 계산해 오라고 해. (재귀 호출)
    int right_size = calc_size(subtree->right);

    // 3. 왼쪽 자식들의 총 용량(left_size)과 오른쪽 자식들의 총 용량(right_size)을 다 받은 뒤,
    //    현재 내 폴더(subtree->data)의 용량까지 합쳐서 그 결과를 반환해.
    //    이게 바로 '후위 순회' (L: 왼쪽 -> R: 오른쪽 -> V: 자신 방문) 방식이야.
    return (subtree->data + left_size + right_size);
}

// 프로그램의 시작점
int main() {
    // 트리 관리 구조체를 위한 메모리를 빌려와.
    BinaryTree* tree = (BinaryTree*)malloc(sizeof(BinaryTree));
    init_tree(tree); // 트리 초기화 (root = NULL)

    int N;
    scanf("%d\n", &N); // 총 몇 개의 노드(폴더)를 만들지 숫자를 입력받아.

    // N개의 노드 '포인터(주소)'를 저장할 수 있는 배열(주소록)을 만들어.
    // (이렇게 하면 0번, 1번, ... N-1번 노드를 쉽게 찾아갈 수 있어.)
    TreeNode** node = (TreeNode**)malloc(sizeof(TreeNode*) * N);
    
    // N개의 노드 각각이 실제로 데이터를 저장할 메모리 공간을 빌려와.
    for (int i = 0; i < N; i++) 
        node[i] = (TreeNode*)malloc(sizeof(TreeNode));

    // N번 반복하면서 각 노드(폴더)의 정보를 한 줄씩 입력받아.
    for (int i = 0; i < N; i++) {
        TreeNode *l_node, *r_node;
        int root_data, left_id, right_id;

        // (예: "100 1 2") -> "i번 노드의 용량은 100이고, 왼쪽 자식은 1번, 오른쪽 자식은 2번이다"
        scanf("%d %d %d", &root_data, &left_id, &right_id);

        // 자식 노드 설정:
        // 'left_id'가 -1이면 자식이 없다는 뜻 (NULL).
        // -1이 아니면, 아까 만들어둔 주소록(node 배열)에서 'left_id'번째 노드의 주소를 가져와.
        l_node = (left_id == -1) ? NULL : node[left_id];
        r_node = (right_id == -1) ? NULL : node[right_id];

        // i번째 노드에 입력받은 정보를 채워 넣어.
        node[i]->data = root_data;  // 용량
        node[i]->left = l_node;     // 왼쪽 자식 노드의 주소
        node[i]->right = r_node;    // 오른쪽 자식 노드의 주소
    }
    
    // 0번 노드(보통 첫 번째로 입력된 노드)를 이 트리의 전체 '뿌리(root)'로 설정해.
    tree->root = node[0];

    // 'calc_size' 함수를 호출해서 0번 노드(root)부터 시작하는
    // 전체 폴더 용량을 계산하고, 그 결과를 "KB" 단위와 함께 출력해.
    printf("폴더 용량 = %d KB\n", calc_size(tree->root));

    // 사용이 끝난 메모리는 운영체제에 꼭 '반납(free)'해줘야 해. (메모리 누수 방지!)
    for (int i = 0; i < N; i++) free(node[i]); // N개의 노드 메모리 반납
    free(node);  // 노드 주소록(배열) 메모리 반납
    free(tree);  // 트리 관리 구조체 메모리 반납

    return 0; // 프로그램 정상 종료
}
