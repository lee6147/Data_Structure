#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef int TreeElement;
typedef struct TreeNode {
    TreeElement data;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;

typedef struct {
    TreeNode* root;
} BinaryTree;

void init_tree(BinaryTree* tree) { tree->root = NULL; }
int is_empty_tree(BinaryTree* tree) { return tree->root == NULL; }

TreeNode* create_tree_node(TreeElement val, TreeNode* l, TreeNode* r) {
    TreeNode* root = (TreeNode*)malloc(sizeof(TreeNode));
    root->data = val;
    root->left = l;   // 왼쪽 서브트리
    root->right = r;  // 오른쪽 서브트리
    return root;
}

int get_leaf_count(TreeNode* subroot) {
    // === Gems가 채운 코드 시작 ===
    
    // 단말 노드의 개수를 세어 저장할 변수입니다. 0으로 시작합니다.
    int count = 0;
    
    // 1. 현재 노드가 NULL(비어있지 않은)인지 먼저 확인합니다.
    //    (만약 subroot가 NULL이면, 이 if문을 건너뛰고 0을 반환합니다.)
    if (subroot != NULL) {
        
        // 2. "내가 단말 노드인가?" 확인
        //    왼쪽 자식(left)도 없고(NULL) AND 오른쪽 자식(right)도 없으면
        //    이 노드는 '단말 노드'입니다.
        if (subroot->left == NULL && subroot->right == NULL)
            return 1; // 1개를 찾았으므로 '1'을 반환합니다.
        
        // 3. "내가 단말 노드가 아니라면?" (자식이 하나라도 있다면)
        //    이 노드는 '중간 노드'입니다.
        else
            // 왼쪽 자식에게 "네 아래 잎 노드가 몇 개니?"라고 물어보고 (재귀 호출)
            // 오른쪽 자식에게 "네 아래 잎 노드가 몇 개니?"라고 물어봐서 (재귀 호출)
            // 그 두 개수를 더한 값을 count에 저장합니다.
            count = get_leaf_count(subroot->left) +
                    get_leaf_count(subroot->right);
    }
    
    // 4. 최종 결과 반환
    //    - subroot가 NULL이었으면 -> 0이 반환됩니다.
    //    - subroot가 단말 노드였으면 -> (2번에서) 1이 반환됩니다.
    //    - subroot가 중간 노드였으면 -> 자식들의 잎 노드 개수 합(count)이 반환됩니다.
    return count;
    
    // === Gems가 채운 코드 끝 ===
}


int main() {
    BinaryTree* tree = (BinaryTree*)malloc(sizeof(BinaryTree));
    init_tree(tree);  // 트리 초기화

    int N;
    scanf("%d\n", &N);  // 노드의 개수

    // 트리 노드 메모리 풀 생성
    TreeNode** node = (TreeNode**)malloc(sizeof(TreeNode*) * N);
    for (int i = 0; i < N; i++) node[i] = (TreeNode*)malloc(sizeof(TreeNode));

    for (int i = 0; i < N; i++) {
        TreeNode *tmp, *l_node, *r_node;
        char root, left, right;
        scanf(" %c %c %c", &root, &left, &right);

        l_node = left == '.' ? NULL : node[left - 'A'];
        r_node = right == '.' ? NULL : node[right - 'A'];
        tmp = create_tree_node(root, l_node, r_node);

        node[i]->data = tmp->data;
        node[i]->left = tmp->left;
        node[i]->right = tmp->right;
        free(tmp);
    }
    tree->root = node[0];  // 트리의 루트 노드 설정

    printf("단말의 개수 = %d\n", get_leaf_count(tree->root));

    // 메모리 해제
    for (int i = 0; i < N; i++) free(node[i]);
    free(node);
    free(tree);

    return 0;
}
