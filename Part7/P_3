#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef int TreeElement;
typedef struct TreeNode {
    TreeElement data;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;

typedef struct {
    TreeNode* root;
} BinaryTree;

void init_tree(BinaryTree* tree) { tree->root = NULL; }
int is_empty_tree(BinaryTree* tree) { return tree->root == NULL; }

TreeNode* create_tree_node(TreeElement val, TreeNode* l, TreeNode* r) {
    TreeNode* root = (TreeNode*)malloc(sizeof(TreeNode));
    root->data = val;
    root->left = l;   // 왼쪽 서브트리
    root->right = r;  // 오른쪽 서브트리
    return root;
}

/**
 * @brief 트리의 높이를 계산하는 함수 (PDF 8.트리.pdf, Page 64 참고)
 * @param subroot 현재 높이를 계산하려는 서브트리의 루트 노드
 * @return 계산된 높이 (int)
 */
int get_height(TreeNode* subroot) {
    // === Gems가 채운 코드 시작 ===
    
    // --- 1. 멈추는 조건 (Base Case) ---
    // '재귀'는 멈추는 조건이 가장 중요해요.
    // 만약 확인하려는 노드(subroot)가 'NULL' (비어있다)이면,
    // 그 노드는 존재하지 않는 것이므로 높이는 '0' 입니다.
    // 이것이 재귀 호출이 멈추는 지점입니다. (예: 잎 노드의 자식)
    if (subroot == NULL) {
        return 0; // 높이 0을 반환하고 함수를 끝냅니다.
    }

    // --- 2. 재귀 호출 (Recursive Step) ---
    // 현재 노드(subroot)가 존재하므로 (NULL이 아니므로),
    // 이 노드의 높이를 알기 위해 먼저 왼쪽과 오른쪽 자식들의 높이를 알아내야 합니다.
    // 'get_height' 함수가 자기 자신을 다시 호출합니다.
    
    // 왼쪽 자식에게 "너의 높이가 얼마니?"라고 물어봅니다 (재귀 호출).
    int left_height = get_height(subroot->left);
    
    // 오른쪽 자식에게 "너의 높이가 얼마니?"라고 물어봅니다 (재귀 호출).
    int right_height = get_height(subroot->right);

    // --- 3. 결과 합치기 (Combine) ---
    // (PDF '8.트리.pdf', Page 64의 'max(...)' 로직입니다.)
    // 이제 'left_height'와 'right_height'에
    // 왼쪽과 오른쪽 서브트리의 높이 계산 결과가 담겨있습니다.
    
    // 트리의 전체 높이는 "더 깊은(높은) 자식의 높이 + 1 (나 자신의 높이)" 입니다.
    
    // 왼쪽 서브트리 높이가 오른쪽 서브트리 높이보다 더 큰가요?
    if (left_height > right_height) {
        // 네, 왼쪽이 더 큽니다.
        // 그럼 (왼쪽 높이 + 1)을 이 함수의 결과로 반환합니다.
        return 1 + left_height;
    } else {
        // 아니요, 오른쪽이 더 크거나 둘이 같습니다.
        // 그럼 (오른쪽 높이 + 1)을 이 함수의 결과로 반환합니다.
        return 1 + right_height;
    }
    // 이 과정이 맨 아래 잎 노드(자식이 없는 노드)부터
    // 루트 노드까지 거슬러 올라오며 반복됩니다.
    
    // === Gems가 채운 코드 끝 ===
}

int main() {
    BinaryTree* tree = (BinaryTree*)malloc(sizeof(BinaryTree));
    init_tree(tree);  // 트리 초기화

    int N;
    scanf("%d\n", &N);  // 노드의 개수

    // 트리 노드 메모리 풀 생성
    TreeNode** node = (TreeNode**)malloc(sizeof(TreeNode*) * N);
    for (int i = 0; i < N; i++) node[i] = (TreeNode*)malloc(sizeof(TreeNode));

    for (int i = 0; i < N; i++) {
        TreeNode *tmp, *l_node, *r_node;
        char root, left, right;
        scanf(" %c %c %c", &root, &left, &right);

        l_node = left == '.' ? NULL : node[left - 'A'];
        r_node = right == '.' ? NULL : node[right - 'A'];
        tmp = create_tree_node(root, l_node, r_node);

        node[i]->data = tmp->data;
        node[i]->left = tmp->left;
        node[i]->right = tmp->right;
        free(tmp);
  D }
    tree->root = node[0];  // 트리의 루트 노드 설정

    printf("트리의 높이 = %d\n", get_height(tree->root));

    // 메모리 해제
    for (int i = 0; i < N; i++) free(node[i]);
    free(node);
    free(tree);

    return 0;
}
