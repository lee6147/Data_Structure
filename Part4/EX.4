#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_QUEUE_SIZE 100
#define Element int

Element queue[MAX_QUEUE_SIZE]; // 정수형 요소를 저장하는 큐 배열

int front; // 큐의 시작 위치를 가리키는 인덱스 (첫 번째 요소 바로 앞)
int rear;  // 큐의 끝 위치를 가리키는 인덱스 (마지막 요소)

void error(char *str)
{
    fprintf(stderr, "%s\n", str);
    exit(1);
};

// 큐를 초기화하는 함수
void init_queue() {
    // front와 rear를 0으로 설정하여 큐를 비어있는 상태로 만듭니다.
    // front와 rear가 같으면 큐는 비어있습니다.
    front = rear = 0;
}

// 큐가 비어있는지 확인하는 함수
int is_empty() {
    // front와 rear 인덱스가 같으면 큐에 요소가 없는 것입니다.
    return front == rear;
}

// 큐가 가득 찼는지 확인하는 함수
int is_full() {
    // rear 다음 위치가 front와 같으면 큐가 가득 찬 것입니다.
    // (rear + 1) % MAX_QUEUE_SIZE는 rear를 원형으로 한 칸 이동시킨 위치를 의미합니다.
    // 이 공간을 비워둠으로써 공백 상태(front == rear)와 포화 상태를 구분합니다.
    return (rear + 1) % MAX_QUEUE_SIZE == front;
}

// 큐에 들어있는 요소의 개수를 반환하는 함수
int size() {
    // rear와 front의 차이를 이용해 크기를 계산합니다.
    // rear가 front보다 작을 경우 (배열의 끝에서 앞으로 돌아간 경우) 음수가 나올 수 있으므로,
    // MAX_QUEUE_SIZE를 더해준 후 모듈러 연산을 수행하여 정확한 크기를 구합니다.
    return (rear - front + MAX_QUEUE_SIZE) % MAX_QUEUE_SIZE;
}

// 큐의 뒤쪽(rear)에 요소를 추가하는 함수 (인큐)
void enqueue(Element val)
{
    // 큐가 가득 찼는지 먼저 확인합니다.
    if (is_full())
        error("큐 포화 에러");
    // rear를 다음 위치로 원형 이동시킵니다.
    rear = (rear + 1) % MAX_QUEUE_SIZE;
    // 새로운 rear 위치에 값을 저장합니다.
    queue[rear] = val;
}

// 큐의 앞쪽(front)에서 요소를 삭제하고 반환하는 함수 (디큐)
Element dequeue()
{
    // 큐가 비어있는지 먼저 확인합니다.
    if (is_empty())
        error("큐 공백 에러");
    // front를 다음 위치로 원형 이동시켜 가장 앞에 있던 요소를 제외시킵니다.
    front = (front + 1) % MAX_QUEUE_SIZE;
    // 방금 제외시킨 (현재 front가 가리키는) 요소를 반환합니다.
    return queue[front];
}

// 큐의 앞쪽(front) 요소를 삭제하지 않고 확인하는 함수
Element peek()
{
    // 큐가 비어있는지 먼저 확인합니다.
    if (is_empty())
        error("큐 공백 에러");
    // front는 첫 번째 요소의 '바로 앞'을 가리키므로,
    // (front + 1) % MAX_QUEUE_SIZE 위치가 실제 첫 번째 요소의 인덱스입니다.
    return queue[(front + 1) % MAX_QUEUE_SIZE];
}


int main(void)
{
    Element num;
    int n;
    char c[10];
    init_queue();
    scanf("%d", &n);
    for (int i = 0; i < n; i++)
    {
        scanf("%s", c);

        if (strcmp(c, "enqueue") == 0)
        {
            scanf("%d\n", &num);
            enqueue(num);
        }
        else if (strcmp(c, "dequeue") == 0)
            printf("%d\n", dequeue());
        else if (strcmp(c, "size") == 0)
            printf("%d\n", size());
        else if (strcmp(c, "empty") == 0)
            printf("%d\n", is_empty());
        else if (strcmp(c, "full") == 0)
            printf("%d\n", is_full());
        else if (strcmp(c, "peek") == 0)
            printf("%d\n", peek());
        else
            printf("error\n");
    }
    return 0;
}
