#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_QUEUE_SIZE 100
#define Element int

Element queue[MAX_QUEUE_SIZE]; // 손님들이 서 있는 대기 줄 (배열)

int front; // 대기 줄의 맨 앞 위치 (다음에 들어갈 손님 바로 앞의 번호표)
int rear;  // 대기 줄의 맨 뒤 위치 (마지막 손님의 번호표)

void error(char *str)
{
    fprintf(stderr, "%s\n", str);
    exit(1);
};

// 큐를 초기화하는 함수 (은행 문을 열고 대기 줄을 준비하는 것과 같아요)
void init_queue() {
    // front와 rear를 0으로 설정하여 아무도 없는 상태로 시작합니다.
    // front와 rear가 같으면 대기 줄이 비어있는 것입니다.
    front = rear = 0;
}

// 큐가 비어있는지 확인하는 함수
int is_empty() {
    // front와 rear 번호표가 같다면, 대기 손님이 아무도 없는 것이죠.
    return front == rear;
}

// 큐가 가득 찼는지 확인하는 함수
int is_full() {
    // 대기 줄이 꽉 찼는지 확인해요. 원활한 관리를 위해 한 자리는 항상 비워둡니다.
    // rear의 바로 다음 칸이 front라면, 비워둔 한 자리를 빼고는 꽉 찬 거예요.
    // (rear + 1) % MAX_QUEUE_SIZE는 대기 줄의 끝에서 다시 앞으로 돌아가는 상황을 처리해줍니다.
    return (rear + 1) % MAX_QUEUE_SIZE == front;
}

// 큐에 들어있는 요소(손님)의 수를 반환하는 함수
int size() {
    // 현재 대기 중인 손님이 몇 명인지 계산합니다.
    // rear가 front보다 작은 경우(줄이 배열 끝에서 앞으로 이어진 경우)를 처리하기 위해
    // MAX_QUEUE_SIZE를 더한 후 나머지 연산을 하여 정확한 인원수를 구합니다.
    return (rear - front + MAX_QUEUE_SIZE) % MAX_QUEUE_SIZE;
}

// 큐의 뒤쪽(rear)에 요소(손님)를 추가하는 함수 (번호표를 뽑고 줄을 서는 것)
void enqueue(Element val)
{
    // 대기 줄이 꽉 찼는지 먼저 확인합니다.
    if (is_full())
        error("큐 포화 에러");
    // rear 번호표를 다음 번호로 바꾸고 (줄이 꽉 차면 다시 0번으로)
    rear = (rear + 1) % MAX_QUEUE_SIZE;
    // 새로 온 손님(val)을 그 자리에 세웁니다.
    queue[rear] = val;
}

// 큐의 앞쪽(front)에서 요소(손님)를 내보내는 함수 (창구에서 업무를 보는 것)
Element dequeue()
{
    // 대기 손님이 있는지 먼저 확인합니다.
    if (is_empty())
        error("큐 공백 에러");
    // front 번호표를 다음 번호로 바꾸어, 맨 앞 손님을 들여보냅니다.
    front = (front + 1) % MAX_QUEUE_SIZE;
    // 방금 업무를 보러 들어간 손님(새로운 front 위치의 값)을 반환합니다.
    return queue[front];
}

// 큐의 맨 앞 요소(손님)를 확인만 하는 함수
Element peek()
{
    // 대기 손님이 있는지 먼저 확인합니다.
    if (is_empty())
        error("큐 공백 에러");
    // front는 '다음에 들어갈 손님의 바로 앞 번호표'이므로,
    // 실제 다음 손님은 (front + 1) 위치에 있습니다. 그 손님이 누구인지 확인만 합니다.
    return queue[(front + 1) % MAX_QUEUE_SIZE];
}


int main(void)
{
    Element num;
    int n;
    char c[10];
    init_queue();
    scanf("%d", &n);
    for (int i = 0; i < n; i++)
    {
        scanf("%s", c);

        if (strcmp(c, "enqueue") == 0)
        {
            scanf("%d\n", &num);
            enqueue(num);
        }
        else if (strcmp(c, "dequeue") == 0)
            printf("%d\n", dequeue());
        else if (strcmp(c, "size") == 0)
            printf("%d\n", size());
        else if (strcmp(c, "empty") == 0)
            printf("%d\n", is_empty());
        else if (strcmp(c, "full") == 0)
            printf("%d\n", is_full());
        else if (strcmp(c, "peek") == 0)
            printf("%d\n", peek());
        else
            printf("error\n");
    }
    return 0;
}
