#include <stdio.h>      // 표준 입출력 함수(printf, getchar 등)를 사용하기 위해 포함합니다.
#include <string.h>     // 문자열 처리 함수(strtok 등)를 사용하기 위해 포함합니다.
#include <ctype.h>      // 문자 종류 판별 함수(isdigit 등)를 사용하기 위해 포함합니다.
#include <stdlib.h>     // 문자열을 숫자로 변환하는 함수(atoi)와 프로그램 종료 함수(exit)를 사용하기 위해 포함합니다.

#define MAX_STACK_SIZE 100 // 스택이 최대로 저장할 수 있는 공간의 크기를 100으로 정합니다.

typedef int element;       // 스택에 저장될 데이터의 타입을 int로 정하고, 'element'라는 별명을 붙여줍니다.
element data[MAX_STACK_SIZE]; // element 타입(int)의 데이터를 저장할 배열(스택의 본체)을 선언합니다.
int top;                   // 스택의 가장 꼭대기에 있는 데이터의 위치를 가리킬 변수입니다.

// 스택을 초기화하는 함수입니다. 계산 시작 전에 한 번 호출하여 스택을 깨끗하게 비웁니다.
void init_stack() {
    top = -1; // top을 -1로 설정합니다. -1은 '스택이 비어있다'는 의미의 약속입니다.
}

// 스택이 비어있는지 확인하는 함수입니다.
int is_empty() {
    return (top == -1); // top이 -1이면 '참(true)'을 반환하고, 아니면 '거짓(false)'을 반환합니다.
}

// 스택이 가득 찼는지 확인하는 함수입니다.
int is_full() {
    // top이 '최대 크기 - 1'과 같다면(배열 인덱스는 0부터 시작하므로), 스택이 꽉 찬 것입니다.
    return (top == MAX_STACK_SIZE - 1);
}

// 스택에 저장된 데이터의 개수를 반환하는 함수입니다.
int size() {
    return top + 1; // top이 0부터 시작하므로, 개수는 top + 1이 됩니다.
}

// 스택에 데이터를 추가하는(push) 함수입니다.
void push(element item)
{
    // 스택이 가득 찼는지 먼저 확인합니다.
    if (is_full()) {
        fprintf(stderr, "스택이 가득 찼습니다.\n"); // 에러 메시지를 출력합니다.
        return; // 함수를 종료합니다.
    }
    // top을 1 증가시켜 다음 위치를 가리키게 한 후, 그 위치에 데이터를 저장합니다.
    data[++top] = item;
}

// 스택에서 데이터를 꺼내는(pop) 함수입니다.
element pop()
{
    // 스택이 비어있는지 먼저 확인합니다.
    if (is_empty()) {
        fprintf(stderr, "스택이 비어있습니다.\n"); // 에러 메시지를 출력합니다.
        exit(1); // 프로그램이 비정상적으로 종료되었음을 알리며 강제 종료합니다.
    }
    // 현재 top이 가리키는 위치의 데이터를 반환한 후, top을 1 감소시켜 한 칸 아래를 가리키게 합니다.
    return data[top--];
}

// 스택의 가장 위 데이터를 확인만 하는(peek) 함수입니다. (데이터를 꺼내지는 않습니다)
element peek()
{
    // 스택이 비어있는지 먼저 확인합니다.
    if (is_empty()) {
        fprintf(stderr, "스택이 비어있습니다.\n"); // 에러 메시지를 출력합니다.
        exit(1); // 프로그램 강제 종료
    }
    // 현재 top이 가리키는 위치의 데이터를 반환합니다. top 값은 변하지 않습니다.
    return data[top];
}


// 후위 표기식 문자열을 받아 계산하는 핵심 함수입니다.
int eval(char exp[])
{
    int op1, op2; // 연산할 때 스택에서 꺼낸 두 개의 숫자를 잠시 담아둘 변수입니다.
    char* token;  // 공백으로 잘라낸 문자열(숫자 또는 연산자) 조각을 가리킬 포인터 변수입니다.

    init_stack(); // 계산을 시작하기 전에 스택을 깨끗하게 초기화합니다.

    // strtok 함수: 'exp' 문자열을 "공백, 줄바꿈, 탭"을 기준으로 잘라 첫 번째 조각(token)을 찾아냅니다.
    token = strtok(exp, " \n\t");

    // 더 이상 잘라낼 조각(token)이 없을 때까지 반복합니다.
    while (token != NULL) {
        // 잘라낸 조각(token)의 첫 글자가 숫자인지 확인합니다.
        // ex) "8", "123" 같은 토큰
        if (isdigit(token[0])) {
            // atoi 함수: "123" 같은 숫자 모양의 문자열을 실제 정수 123으로 변환합니다.
            // 변환된 정수를 스택에 push 합니다.
            push(atoi(token));
        }
        // 첫 글자가 숫자가 아니라면 연산자라고 가정합니다.
        // ex) "+", "-", "*", "/" 같은 토큰
        else {
            // 연산을 위해 스택에서 숫자 두 개를 꺼냅니다.
            // 중요! 나중에 들어간 것이 먼저 나오므로 op2에 먼저 저장됩니다.
            // 예: "8 2 /" 의 경우, 스택에는 8, 2 순서로 들어갔으므로
            // pop()을 하면 2가 먼저 나오고, 그 다음 8이 나옵니다.
            op2 = pop(); // 두 번째 피연산자
            op1 = pop(); // 첫 번째 피연산자

            // 연산자 종류에 따라 적절한 계산을 수행합니다.
            switch (token[0]) {
                // 계산한 결과를 다시 스택에 push 합니다.
                // 이 결과는 다음 연산에 사용될 수 있습니다.
            case '+': push(op1 + op2); break;
            case '-': push(op1 - op2); break;
            case '*': push(op1 * op2); break;
            case '/': push(op1 / op2); break;
            }
        }
        // strtok에 NULL을 전달하면, 이전에 작업했던 문자열에서 다음 조각을 계속 찾습니다.
        token = strtok(NULL, " \n\t");
    }

    // 모든 계산이 끝나면 스택에는 최종 결과값 하나만 남게 됩니다.
    // 그 최종 결과값을 pop 하여 반환합니다.
    return pop();
}

int main() {
    int i = 0;
    char t = 0;
    char in[1000] = { 0 }; // 입력을 전부 저장할 큰 문자 배열을 준비합니다.

    // 사용자가 입력을 끝낼 때까지(EOF, End-Of-File 신호) 한 글자씩 계속 읽어옵니다.
    // (Windows에서는 Ctrl+Z, Linux/macOS에서는 Ctrl+D를 누르면 입력이 끝납니다)
    while ((t = getchar()) != EOF) {
        in[i++] = t; // 읽어온 글자를 in 배열에 차례대로 저장합니다.
    }
    in[i] = '\0'; // 문자열의 끝을 알리는 NULL 문자를 추가합니다.

    // eval 함수에 입력받은 전체 문자열을 전달하여 계산하고, 그 결과를 출력합니다.
    printf("%d\n", eval(in));

    return 0; // 프로그램을 정상적으로 종료합니다.
}
