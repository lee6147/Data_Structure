#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

#define MAX_STACK_SIZE 100

// ----- 스택 관련 전역 -----
// element 타입을 char로 변경했습니다. 연산자('+', '*', '(' 등)는 문자이므로
// char 타입으로 저장하는 것이 더 명확합니다.
typedef char element; 
element stack[MAX_STACK_SIZE];
int top;

// ----- 스택 관련 함수들 -----
void init_stack()
{
    top = -1; // 스택 초기화
}
int is_empty()
{
    return (top == -1);
}
int is_full()
{
    return (top == MAX_STACK_SIZE - 1);
}
int size()
{
    return top + 1;
}
void push(element item)
{
    if (!is_full())
        stack[++top] = item;
}
element pop()
{
    if (is_empty())
        return -1; // 언더플로우 방지
    return stack[top--];
}
element peek()
{
    if (is_empty())
        return -1;
    return stack[top];
}

// ----- 연산자 우선순위 함수 -----
// 각 연산자에 대한 우선순위(계산 순서)를 숫자로 정해주는 함수입니다.
// 숫자가 높을수록 우선순위가 높습니다.
int prec(char op)
{
    // FILL the code
    switch (op) {
        // 괄호는 계산 우선순위가 가장 낮지만, 다른 연산자들의 순서를 정하는 데 사용됩니다.
        case '(': case ')': 
            return 0;
        // 덧셈과 뺄셈은 우선순위가 같습니다.
        case '+': case '-': 
            return 1;
        // 곱셈과 나눗셈은 덧셈/뺄셈보다 우선순위가 높습니다.
        case '*': case '/': 
            return 2;
    }
    // op가 연산자가 아닌 경우 -1을 반환합니다.
    return -1;
}

// ----- 중위 -> 후위 변환 함수 -----
// 우리가 흔히 쓰는 '1 + 2' 같은 식(중위 표기식)을
// 컴퓨터가 계산하기 편한 '1 2 +' 형태(후위 표기식)로 바꿔주는 함수입니다.
void infix_to_postfix(char infix_expr[], char postfix_expr[])
{
    // FILL the code
    char ch, top_op;
    
    // strtok 함수는 '8 / 2 - 3' 같은 식을 공백 기준으로 '8', '/', '2', '-', '3' 처럼 잘라줍니다.
    // 이렇게 잘린 하나하나를 '토큰(token)'이라고 부릅니다.
    char *token = strtok(infix_expr, " \n\t");

    // 더 이상 자를 토큰이 없을 때까지 반복합니다.
    while (token != NULL) {
        ch = token[0]; // 현재 토큰의 첫 글자를 ch에 저장합니다. (예: '8', '/', '(' 등)
        
        // 1. 토큰이 숫자인 경우 (피연산자)
        if (isdigit(ch)) {
            // 숫자는 순서가 바뀌지 않으므로 바로 결과(postfix_expr)에 추가합니다.
            strcat(postfix_expr, token);
            // 다음 토큰과 구분을 위해 뒤에 띄어쓰기를 추가합니다.
            strcat(postfix_expr, " ");
        }
        // 2. 토큰이 왼쪽 괄호 '(' 인 경우
        else if (ch == '(') {
            // 왼쪽 괄호는 나중에 오른쪽 괄호를 만날 때까지 연산자들을 담아두는 역할을 합니다.
            // 일단 스택에 넣어둡니다.
            push(ch);
        }
        // 3. 토큰이 오른쪽 괄호 ')' 인 경우
        else if (ch == ')') {
            // 스택에서 연산자를 하나 꺼냅니다.
            top_op = pop();
            // 스택에서 꺼낸 연산자가 왼쪽 괄호 '(' 가 아닐 동안 반복합니다.
            while (top_op != '(') {
                // 괄호 안에 있던 연산자들을 모두 결과에 추가합니다.
                // strlen(postfix_expr)는 현재 결과 문자열의 길이를 알려줍니다.
                // 즉, 문자열의 맨 끝에 문자를 추가하는 것입니다.
                postfix_expr[strlen(postfix_expr)] = top_op;
                strcat(postfix_expr, " "); // 띄어쓰기 추가
                // 다시 스택에서 다음 연산자를 꺼냅니다.
                top_op = pop();
            }
            // while문이 끝나면 '('를 찾았다는 뜻이므로, 괄호 안의 연산자 정리가 끝난 것입니다.
        }
        // 4. 토큰이 그 외의 연산자(+, -, *, /)인 경우
        else {
            // 스택이 비어있지 않고, "스택 맨 위의 연산자"가 "현재 연산자"보다 우선순위가 높거나 같으면
            // 스택의 연산자를 먼저 계산해야 합니다.
            while (!is_empty() && (prec(ch) <= prec(peek()))) {
                // 스택 맨 위의 연산자를 꺼내서 결과에 추가합니다.
                 postfix_expr[strlen(postfix_expr)] = pop();
                 strcat(postfix_expr, " ");
            }
            // 이제 현재 연산자를 스택에 넣습니다.
            push(ch);
        }
        // 다음 토큰을 잘라옵니다.
        token = strtok(NULL, " \n\t");
    }

    // 5. 입력식을 모두 처리한 후, 스택에 연산자가 남아있다면
    // 모두 꺼내서 결과에 추가합니다.
    while (!is_empty()) {
        postfix_expr[strlen(postfix_expr)] = pop();
        strcat(postfix_expr, " ");
    }
    
    // 위 과정에서 마지막에 불필요한 공백이 하나 추가되므로, 그것을 제거합니다.
    if (strlen(postfix_expr) > 0) {
        postfix_expr[strlen(postfix_expr) - 1] = '\0'; // '\0'은 문자열의 끝을 의미합니다.
    }
}


// ----- 메인 함수 -----
// 표준 입력에서 중위식을 받아 후위식으로 변환 후 출력
int main()
{
    int i = 0;
    char input_char = 0;
    char infix_expr[1000] = {0};
    char postfix_expr[1000] = {0};

    // 표준 입력으로 중위 표기식 읽기
    // 엔터키(EOF)가 입력될 때까지 한 글자씩 읽어들입니다.
    while ((input_char = getchar()) != EOF && input_char != '\n') {
        infix_expr[i++] = input_char;
    }
    infix_expr[i] = '\0';

    // 스택을 사용하기 전에 항상 초기화를 해줍니다.
    init_stack();

    // 중위 표기식을 후위 표기식으로 변환하는 함수를 호출합니다.
    infix_to_postfix(infix_expr, postfix_expr);

    // 변환된 결과를 화면에 출력합니다.
    printf("%s\n", postfix_expr);

    return 0;
}
