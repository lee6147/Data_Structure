#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

#define MAX_STACK_SIZE 100

typedef int element;
element data[MAX_STACK_SIZE];
int top;

// 스택을 처음 상태로 만들어주는 함수 (초기화)
void init_stack() {
    // top은 스택의 가장 꼭대기를 가리키는 위치인데, -1은 '아무것도 없음'을 의미해요.
    top = -1;
}

// 스택이 비어있는지 확인하는 함수
int is_empty() {
    // top이 -1이면 데이터가 하나도 없는 것이므로, '비어있다'는 의미로 참(1)을 반환해요.
    return (top == -1);
}

// 스택이 꽉 찼는지 확인하는 함수
int is_full() {
    // top이 스택의 마지막 칸(MAX_STACK_SIZE - 1)에 도달했다면, '가득 찼다'는 의미로 참(1)을 반환해요.
    return (top == MAX_STACK_SIZE - 1);
}

// 스택에 데이터가 몇 개 들어있는지 알려주는 함수
int size() {
    // top은 0부터 시작하는 위치(인덱스)라서, 개수는 항상 top + 1 이 돼요.
    return top + 1;
}

// 스택에 데이터를 하나 넣는(push) 함수
void push(element item)
{
    // 만약 스택이 가득 찼다면, 더 이상 넣을 공간이 없으므로 아무것도 하지 않고 함수를 끝내요.
    if (is_full())
        return;

    // '++top'은 top의 위치를 먼저 1 증가시킨다는 뜻이에요.
    // 예를 들어 top이 -1이었다면 0으로 만들고, 그 0번째 칸에 item을 저장해요.
    data[++top] = item;
}

// 스택에서 데이터를 하나 꺼내는(pop) 함수
element pop()
{
    // 만약 스택이 비어있다면, 꺼낼 데이터가 없으므로 -1(오류 표시)을 반환하고 함수를 끝내요.
    if (is_empty())
        return -1;

    // 'top--'는 현재 top 위치의 데이터를 먼저 꺼내고(반환하고), 그 다음에 top 위치를 1 감소시킨다는 뜻이에요.
    // 이렇게 하면 맨 위 데이터가 사라지는 효과가 나요.
    return data[top--];
}

// 스택의 맨 위 데이터를 삭제하지 않고 살짝 엿보는(peek) 함수
element peek()
{
    // 만약 스택이 비어있다면, 볼 데이터가 없으므로 -1(오류 표시)을 반환하고 함수를 끝내요.
    if (is_empty())
        return -1;

    // pop과 다르게 top의 위치를 바꾸지 않고, 그냥 맨 위 데이터를 보여주기만 해요.
    return data[top];
}

// 후위 표기법으로 된 수식(exp)을 계산하는 함수
int eval(char exp[])
{
    // 연산할 때 사용할 왼쪽 숫자(피연산자)와 오른쪽 숫자를 저장할 변수예요.
    int left_operand, right_operand;

    // 계산을 시작하기 전에 스택을 깨끗하게 비워요.
    init_stack();

    // strtok 함수는 긴 문자열(exp)을 공백(" ")을 기준으로 잘라주는 역할을 해요.
    // for 반복문은 잘라낸 조각(token)이 없을 때까지 계속 실행돼요.
    // char *token은 잘라낸 문자 조각(예: "10", "+", "5")을 임시로 저장하는 변수예요.
    for (char *token = strtok(exp, " "); token != NULL; token = strtok(NULL, " ")) {

        // isdigit(token[0])는 토큰의 첫 글자가 숫자인지 확인하는 거예요.
        if (isdigit(token[0])) {
            // 토큰이 숫자이면, atoi 함수를 사용해 문자열을 진짜 정수로 바꿔서 스택에 넣어요.
            // 예를 들어 "10" 이라는 글자를 10 이라는 숫자로 바꿔줘요.
            push(atoi(token));
        }
        else // 토큰이 숫자가 아니고 연산자(+, -, *, /)인 경우
        {
            // 연산 결과를 저장할 변수예요.
            int result;
            // 토큰(예: "+")에서 첫 번째 글자인 연산자를 op 변수에 저장해요.
            char op = token[0];

            // 연산자는 숫자 2개가 필요하니까, 스택에서 숫자 2개를 꺼내요.
            // 중요! 스택에서는 나중에 넣은 게 먼저 나오므로, 오른쪽 숫자를 먼저 꺼내야 해요.
            right_operand = pop();
            left_operand = pop();

            // switch는 op 변수에 들어있는 연산자에 따라 알맞은 계산을 해요.
            switch (op) {
            case '+': // op가 '+' 이면 덧셈을 해요.
                result = left_operand + right_operand;
                break; // 계산이 끝났으면 switch 문을 빠져나가요.
            case '-': // op가 '-' 이면 뺄셈을 해요.
                result = left_operand - right_operand;
                break;
            case '*': // op가 '*' 이면 곱셈을 해요.
                result = left_operand * right_operand;
                break;
            case '/': // op가 '/' 이면 나눗셈을 해요.
                result = left_operand / right_operand;
                break;
            }
            // 두 숫자를 연산한 결과를 다시 스택에 넣어요.
            // 이 결과는 나중에 다른 연산에 사용될 수 있어요.
            push(result);
        }
    }
    // 모든 계산이 끝나면 스택에는 최종 결과값 하나만 남아있게 돼요.
    // 그 최종 결과값을 꺼내서 반환해요.
    return pop();
}

int main() {
    int i = 0;
    char t = 0;
    char in[1000] = {0};
    // char post[1000] = { 0 }; // 사용되지 않으므로 주석 처리하거나 삭제 가능

    // input string (EOF는 Ctrl+Z 또는 Ctrl+D 로 입력)
    while ((t = getchar()) != EOF)
        in[i++] = t;
    in[i] = '\0';

    // output
    printf("%d\n", eval(in));

    return 0;
}
