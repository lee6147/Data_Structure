#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef int Element;             // 연결 리스트에 저장될 데이터의 종류를 '정수(int)'로 정합니다.
typedef struct LinkedNode {
    Element data;                // 노드(데이터 한 칸)에 저장될 실제 값.
    struct LinkedNode* link;     // 다음 노드를 가리키는 '연결 고리' (포인터).
} Node;

// 사용이 끝난 연결 리스트의 모든 노드 메모리를 청소하는 함수.
void free_list(Node* head) {
    Node* current = head;
    while (current != NULL) {
        Node* temp = current;
        current = current->link;
        free(temp);
    }
}

// 연결 리스트를 처음 만들 때 초기화하는 함수.
Node* init_list(Node* head) {
    // 연결 리스트는 기차와 같아요. 처음에는 아무 칸도 없으니,
    // '비어있다'는 뜻의 NULL을 반환해서 빈 기차를 만듭니다.
    return NULL;
}

// 연결 리스트(기차)가 비어있는지 확인하는 함수.
int is_empty(Node* head) {
    // 기차의 맨 앞 칸(head)이 NULL(없음)이면, 기차 전체가 비어있는 것입니다.
    // 맞으면 1(참), 틀리면 0(거짓)을 반환합니다.
    return head == NULL;
}

// 연결 리스트의 크기(기차 칸의 총개수)를 알려주는 함수.
int get_size(Node* head) {
    int count = 0; // 칸 수를 세기 위한 счёт기(카운터)를 0으로 준비합니다.
    Node* p; // 기차 칸을 하나씩 살펴볼 포인터(손가락) p를 준비합니다.

    // p가 맨 앞 칸부터 시작해서, 기차가 끝날 때(NULL)까지 한 칸씩 이동합니다.
    for (p = head; p != NULL; p = p->link) {
        count++; // 한 칸을 지날 때마다 счёт기(카운터)를 1씩 증가시킵니다.
    }
    return count; // 다 세고 나면, 총개수를 반환합니다.
}

// 특정 위치(at)에 있는 노드(기차 칸)를 찾아주는 함수.
Node* get_entry(Node* head, int at) {
    Node* p = head; // p는 기차의 맨 앞 칸부터 시작하는 탐색용 포인터입니다.
    
    // at번 만큼 다음 칸으로 이동합니다. (예: at=2이면 두 번 이동)
    for (int i = 0; i < at; i++) {
        // 목적지에 도착하기 전에 기차가 끝나버리면 (p가 NULL이 되면),
        if (p == NULL) return NULL; // 찾는 칸이 없다는 뜻이므로 NULL을 반환합니다.
        p = p->link; // p를 다음 칸으로 이동시킵니다.
    }
    return p; // at번 만큼 이동한 위치의 노드를 반환합니다.
}

// 특정 위치(at)의 노드 데이터를 data로 교체하는 함수.
Node* replace_at(Node* head, int at, Element data) {
    // 먼저, get_entry 함수를 이용해서 원하는 위치(at)의 노드를 찾습니다.
    Node* p = get_entry(head, at);
    
    // 만약 p가 NULL이 아니라면 (즉, 노드를 성공적으로 찾았다면),
    if (p != NULL) {
        p->data = data; // 그 노드의 데이터를 새로운 data로 덮어씁니다.
    }
    // 교체한 노드의 주소(p)를 반환합니다. 못 찾았다면 p는 NULL일 것입니다.
    return p;
}

// 리스트에서 특정 데이터(data)를 찾아 그 위치(인덱스)를 반환하는 함수.
int search_data(Node* head, Element data) {
    int pos = 0; // 위치를 나타내는 인덱스를 0부터 시작합니다.
    Node* p; // 기차 칸을 하나씩 살펴볼 포인터 p.

    // p가 맨 앞 칸부터 기차 끝까지 이동하면서,
    for (p = head; p != NULL; p = p->link) {
        // 현재 칸의 데이터가 우리가 찾던 data와 똑같은지 확인합니다.
        if (p->data == data) {
            return pos; // 똑같으면, 바로 현재 위치(pos)를 반환하고 함수를 끝냅니다.
        }
        pos++; // 데이터가 다르면, 다음 칸으로 넘어가기 전에 위치(pos)를 1 증가시킵니다.
    }
    // 기차를 끝까지 다 찾아봤는데도 데이터가 없으면, -1을 반환합니다.
    return -1;
}

// 특정 위치(at)에 새로운 데이터(data)를 삽입하는 함수.
Node* insert_at(Node* head, int at, Element data) {
    // 0보다 작은 위치는 없으므로, 아무것도 하지 않고 그냥 돌아갑니다.
    if (at < 0) return head;

    // 삽입할 새 기차 칸(노드)을 하나 만듭니다.
    Node* n = (Node*)malloc(sizeof(Node));
    n->data = data; // 새 칸에 데이터를 넣고,
    n->link = NULL; // 연결 고리는 일단 비워둡니다.

    // Case 1: 기차의 맨 앞(at == 0)에 삽입하는 경우
    if (at == 0) {
        n->link = head;     // 새 칸의 연결 고리를 원래 맨 앞 칸에 연결하고,
        return n;           // 이제 이 새 칸이 기차의 새로운 맨 앞(head)이 됩니다.
    }
    
    // Case 2: 기차의 중간이나 맨 뒤에 삽입하는 경우
    // 삽입할 위치의 '바로 앞 칸'을 찾아야 합니다. (at-1)
    Node* prev = get_entry(head, at - 1); 
    if (prev != NULL) { // '바로 앞 칸'이 존재한다면,
        n->link = prev->link; // 1. 새 칸의 연결 고리를 '앞 칸의 다음 칸'에 먼저 연결하고,
        prev->link = n;       // 2. '앞 칸'의 연결 고리를 끊고 '새 칸'에 연결합니다.
    } else {
        free(n); // '바로 앞 칸'이 없으면 삽입할 수 없으므로, 만들었던 새 칸은 버립니다.
    }
    return head; // 맨 앞 칸은 그대로이므로 head를 반환합니다.
}

// 특정 위치(at)의 노드를 삭제하는 함수.
Node* remove_at(Node* head, int at) {
    // 0보다 작은 위치는 없거나, 기차가 비어있으면 아무것도 하지 않습니다.
    if (at < 0 || head == NULL) return head;

    Node* removed; // 삭제될 노드를 잠시 담아둘 포인터
    
    // Case 1: 기차의 맨 앞(at == 0) 칸을 삭제하는 경우
    if (at == 0) {
        removed = head;         // 현재 맨 앞 칸을 '삭제될 칸'으로 지정하고,
        head = head->link;      // 이제부터 두 번째 칸이 새로운 맨 앞(head)이 됩니다.
        free(removed);          // '삭제될 칸'은 메모리에서 완전히 제거합니다.
    } 
    // Case 2: 중간이나 마지막 칸을 삭제하는 경우
    else {
        // 삭제할 칸의 '바로 앞 칸'을 찾습니다. (at-1)
        Node* prev = get_entry(head, at - 1);
        // '앞 칸'과 '삭제될 칸(앞 칸의 다음 칸)'이 모두 존재한다면,
        if (prev != NULL && prev->link != NULL) {
            removed = prev->link; // '앞 칸'의 다음 칸이 '삭제될 칸'입니다.
            // '앞 칸'의 연결 고리를 '삭제될 칸의 다음 칸'에 바로 연결해서,
            // '삭제될 칸'을 건너뛰게 만들어 연결에서 제외시킵니다.
            prev->link = removed->link; 
            free(removed); // 연결이 끊긴 '삭제될 칸'은 메모리에서 제거합니다.
        }
    }
    return head; // 바뀐 기차의 맨 앞(head)을 반환합니다.
}

// 연결 리스트의 모든 요소를 출력
void print_list(Node* head) {
    Node* p;
    for (p = head; p != NULL; p = p->link) printf("%d->", p->data);
    printf("NULL\n");
}

int main() {
    int i, n;
    char c[20];
    Node *head = NULL;
    head = init_list(head);

    // 수행할 명령어의 수
    scanf("%d", &n);

    // 명령 수행
    for (i = 0; i < n; i++) {
        int at, data;
        scanf("%s", c);
        if (strcmp(c, "empty") == 0) {
            printf("%d\n", is_empty(head));
        } else if (strcmp(c, "size") == 0) {
            printf("%d\n", get_size(head));
        } else if (strcmp(c, "getentry") == 0) {
            scanf("%d", &at);
            Node* entry = get_entry(head, at);
            if (entry != NULL)
                printf("%d\n", entry->data);
            else
                printf("Invalid position\n");
        } else if (strcmp(c, "replace") == 0) {
            scanf("%d %d", &at, &data);
            Node* replaced = replace_at(head, at, data);
            if (replaced != NULL)
                printf("%d\n", replaced->data);
            else
                printf("Invalid position\n");
        } else if (strcmp(c, "search") == 0) {
            scanf("%d", &data);
            int pos = search_data(head, data);
            if (pos != -1)
                printf("Found at position %d\n", pos);
            else
                printf("Not found\n");
        } else if (strcmp(c, "insert") == 0) {
            scanf("%d %d", &at, &data);
            head = insert_at(head, at, data);
            print_list(head);
        } else if (strcmp(c, "remove") == 0) {
            scanf("%d", &at);
            head = remove_at(head, at);
            print_list(head);
        } else
            printf("error\n");
    }

    free_list(head);

    return 0;
}
