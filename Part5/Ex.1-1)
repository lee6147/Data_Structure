#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef int Element;     // 연결 리스트의 요소 타입 정의
typedef struct LinkedNode {
    Element data;              // 노드의 데이터
    struct LinkedNode* link;   // 다음 노드를 가리키는 포인터
} Node;

// 연결 리스트의 모든 노드 메모리를 해제하는 함수
void free_list(Node* head) {
    Node* current = head;
    while (current != NULL) {
        Node* temp = current;
        current = current->link;
        free(temp);
    }
}

/**
 * @brief 연결 리스트를 초기화합니다.
 * @param head 현재 리스트의 헤드 포인터.
 * @return 초기화된 리스트의 헤드 포인터 (항상 NULL).
 * @details main 함수에서 'Node* head = NULL;'로 이미 초기화가 수행됩니다.
 * 따라서 이 함수는 단순히 NULL을 반환하여 리스트가 비어있음을 명확히 합니다.
 */
Node* init_list(Node* head) {
    return NULL;
}

/**
 * @brief 연결 리스트가 비어있는지 확인합니다.
 * @param head 리스트의 헤드 포인터.
 * @return 리스트가 비어있으면 1 (true), 그렇지 않으면 0 (false).
 * @details 리스트가 비어있는 유일한 조건은 헤드 포인터가 NULL인 경우입니다.
 */
int is_empty(Node* head) {
    return head == NULL;
}

/**
 * @brief 연결 리스트의 크기(총 노드의 개수)를 반환합니다.
 * @param head 리스트의 헤드 포인터.
 * @return 리스트에 있는 노드의 총 개수.
 * @details 임시 포인터 'p'를 사용하여 리스트의 처음부터 끝(NULL)까지 순회하며 카운트를 1씩 증가시킵니다.
 */
int get_size(Node* head) {
    int count = 0;
    Node* p = head; // 순회용 포인터
    while (p != NULL) {
        count++;
        p = p->link;
    }
    return count;
}

/**
 * @brief 지정된 위치(at)에 있는 노드의 포인터를 반환합니다.
 * @param head 리스트의 헤드 포인터.
 * @param at 찾고자 하는 노드의 위치 (0부터 시작하는 인덱스).
 * @return 해당 위치의 노드 포인터. 위치가 유효하지 않으면 NULL.
 * @details for 루프를 'at'번 만큼 반복하여 포인터를 다음 노드로 이동시킵니다.
 * 만약 루프 도중 포인터가 NULL이 되면, 'at'이 리스트의 크기를 벗어나는 것이므로 NULL을 반환합니다.
 */
Node* get_entry(Node* head, int at) {
    Node* p = head;
    if (at < 0) return NULL; // 음수 인덱스는 유효하지 않음
    
    for (int i = 0; i < at; i++) {
        if (p == NULL) { // 'at'에 도달하기 전에 리스트의 끝에 도달한 경우
            return NULL;
        }
        p = p->link;
    }
    return p;
}

/**
 * @brief 지정된 위치(at)의 노드 데이터를 주어진 데이터(data)로 교체합니다.
 * @param head 리스트의 헤드 포인터.
 * @param at 데이터를 교체할 노드의 위치 (0-based index).
 * @param data 새로 저장할 데이터.
 * @return 데이터가 교체된 노드의 포인터. 위치가 유효하지 않으면 NULL.
 * @details 먼저 get_entry() 함수를 호출하여 해당 위치의 노드를 찾고,
 * 노드가 존재하면(NULL이 아니면) 해당 노드의 data 멤버를 새로운 데이터로 갱신합니다.
 */
Node* replace_at(Node* head, int at, Element data) {
    Node* node_to_replace = get_entry(head, at);
    if (node_to_replace != NULL) {
        node_to_replace->data = data;
    }
    return node_to_replace;
}

/**
 * @brief 리스트에서 특정 데이터(data)를 검색하여 첫 번째로 나타나는 위치(인덱스)를 반환합니다.
 * @param head 리스트의 헤드 포인터.
 * @param data 찾고자 하는 데이터.
 * @return 데이터가 있는 첫 번째 노드의 인덱스. 데이터를 찾지 못하면 -1.
 * @details while 루프를 이용해 리스트를 순회하면서 각 노드의 데이터와 찾고자 하는 데이터를 비교합니다.
 * 일치하는 데이터를 찾으면 현재의 인덱스를 반환하고, 끝까지 찾지 못하면 -1을 반환합니다.
 */
int search_data(Node* head, Element data) {
    Node* p = head;
    int index = 0;
    while (p != NULL) {
        if (p->data == data) {
            return index;
        }
        p = p->link;
        index++;
    }
    return -1;
}

/**
 * @brief 지정된 위치(at)에 새로운 노드를 삽입합니다.
 * @param head 리스트의 헤드 포인터.
 * @param at 노드를 삽입할 위치 (0-based index). 삽입 가능한 위치는 0부터 리스트 크기까지입니다.
 * @param data 새로 삽입할 데이터.
 * @return 삽입이 반영된 리스트의 새로운 헤드 포인터.
 * @details 1. 새 노드를 동적으로 할당하고 데이터를 저장합니다.
 * 2. at이 0이면 리스트의 맨 앞에 삽입합니다. 새 노드가 새로운 헤드가 됩니다.
 * 3. at이 0보다 크면, 삽입할 위치의 '이전 노드'(at-1)를 찾습니다.
 * 4. 이전 노드의 link를 새 노드에 연결하고, 새 노드의 link를 이전 노드가 가리키던 노드에 연결합니다.
 */
Node* insert_at(Node* head, int at, Element data) {
    if (at < 0 || at > get_size(head)) { // 유효한 삽입 범위: 0 ~ size
        return head;
    }

    Node* new_node = (Node*)malloc(sizeof(Node));
    new_node->data = data;

    if (at == 0) {
        new_node->link = head;
        return new_node;
    }
    
    Node* prev = get_entry(head, at - 1);
    if (prev != NULL) {
        new_node->link = prev->link;
        prev->link = new_node;
    }
    return head;
}

/**
 * @brief 지정된 위치(at)의 노드를 삭제합니다.
 * @param head 리스트의 헤드 포인터.
 * @param at 삭제할 노드의 위치 (0-based index).
 * @return 삭제가 반영된 리스트의 새로운 헤드 포인터.
 * @details 1. at이 0이면 헤드 노드를 삭제합니다. 헤드의 다음 노드가 새로운 헤드가 됩니다.
 * 2. at이 0보다 크면, 삭제할 노드의 '이전 노드'(at-1)를 찾습니다.
 * 3. 이전 노드의 link가 삭제할 노드의 다음 노드를 가리키도록 변경합니다.
 * 4. 마지막으로, 삭제된 노드의 메모리를 해제(free)합니다.
 */
Node* remove_at(Node* head, int at) {
    if (is_empty(head) || at < 0 || at >= get_size(head)) { // 유효한 삭제 범위: 0 ~ size-1
        return head;
    }

    Node* removed;
    if (at == 0) {
        removed = head;
        head = head->link;
        free(removed);
        return head;
    }
    
    Node* prev = get_entry(head, at - 1);
    if (prev != NULL && prev->link != NULL) {
        removed = prev->link;
        prev->link = removed->link;
        free(removed);
    }
    return head;
}

// 연결 리스트의 모든 요소를 출력
void print_list(Node* head) {
    Node* p;
    for (p = head; p != NULL; p = p->link) printf("%d->", p->data);
    printf("NULL\n");
}

int main() {
    int i, n, m, data;
    char c[20];
    Node *head = NULL;
    head = init_list(head);

    // 각 연결 리스트가 수행할 명령어의 수
    scanf("%d %d", &n, &m);

    // 첫번째 연결 리스트 명령 수행
    for (i = 0; i < n; i++) {
        int at, data;
        scanf("%s", c);
        if (strcmp(c, "empty") == 0) {
            printf("%d\n", is_empty(head));
        } else if (strcmp(c, "size") == 0) {
            printf("%d\n", get_size(head));
        } else if (strcmp(c, "getentry") == 0) {
            scanf("%d", &at);
            Node* entry = get_entry(head, at);
            if (entry != NULL)
                printf("%d\n", entry->data);
            else
                printf("Invalid position\n");
        } else if (strcmp(c, "replace") == 0) {
            scanf("%d %d", &at, &data);
            Node* replaced = replace_at(head, at, data);
            if (replaced != NULL)
                printf("%d\n", replaced->data);
            else
                printf("Invalid position\n");
        } else if (strcmp(c, "search") == 0) {
            scanf("%d", &data);
            int pos = search_data(head, data);
            if (pos != -1)
                printf("Found at position %d\n", pos);
            else
                printf("Not found\n");
        } else if (strcmp(c, "insert") == 0) {
            scanf("%d %d", &at, &data);
            head = insert_at(head, at, data);
            print_list(head);
        } else if (strcmp(c, "remove") == 0) {
            scanf("%d", &at);
            head = remove_at(head, at);
            print_list(head);
        } else
            printf("error\n");
    }

    free_list(head);

    return 0;
}
