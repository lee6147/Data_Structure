#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef int element;

// 스택의 각 요소를 나타내는 노드 구조체
typedef struct StackNode
{
    element data; // 데이터
    struct StackNode *link; // 다음 노드를 가리키는 포인터
} StackNode;

// 스택 전체를 관리하는 구조체
typedef struct
{
    StackNode *top; // 스택의 가장 위(가장 최근에 추가된 노드)를 가리키는 포인터
} LinkedStackType;

// 스택이 비어 있는지 확인하는 함수: top 포인터가 NULL인지 검사
int is_empty(LinkedStackType *s)
{
    // top 포인터가 NULL이면 스택이 비어있는 상태
    return (s->top == NULL);
}

// 스택을 초기화하는 함수: top 포인터를 NULL로 설정
void init(LinkedStackType *s)
{
    // 스택의 top을 NULL로 초기화하여 빈 스택으로 만듭니다.
    s->top = NULL;
}

// 스택의 맨 위 데이터를 삭제하지 않고 확인 (Peek)
element peek(LinkedStackType *s)
{
    // 스택이 비어있는 경우 -1 반환
    if (is_empty(s)) // is_empty 함수를 호출하여 스택이 비었는지 확인
        return -1; // 비어있으면 -1 반환
    // 스택이 비어있지 않으면 top 노드의 데이터 반환
    return s->top->data; // top이 가리키는 노드의 데이터를 반환
}

// 스택에 들어있는 요소의 개수를 반환 (Size)
int size(LinkedStackType *s)
{
    StackNode *p; // 스택을 순회하기 위한 임시 포인터
    int count = 0; // 노드 개수를 세는 변수 초기화
    // top 포인터부터 시작하여 리스트의 끝(NULL)까지 순회하며 개수를 셈
    // p를 top으로 초기화하고, p가 NULL이 아닐 동안 반복하며, 각 반복마다 p를 다음 노드로 이동
    for (p = s->top; p != NULL; p = p->link)
        count++; // 노드 개수 증가
    return count; // 계산된 노드 개수 반환
}

// 스택에 새로운 요소를 추가하는 함수 (Push)
void push(LinkedStackType *s, element item)
{
    // 새 노드를 생성하고 데이터를 저장할 포인터 변수 선언 및 메모리 할당
    StackNode *temp = (StackNode *)malloc(sizeof(StackNode));
    // 메모리 할당 실패 시 오류 처리 (PDF 스타일)
    if (temp == NULL) {
        fprintf(stderr, "Memory allocation error\n");
        exit(1);
    }
    // 새 노드에 전달받은 데이터 저장
    temp->data = item;
    // 새 노드의 link가 현재 top 노드를 가리키도록 설정
    temp->link = s->top;
    // top 포인터가 새로 추가된 노드를 가리키도록 업데이트
    s->top = temp;
}

// 스택의 top에서 요소를 삭제하고 반환하는 함수 (Pop)
element pop(LinkedStackType *s)
{
    // 스택이 비어있는지 확인
    if (is_empty(s)) // is_empty 함수를 사용하여 확인
        // 비어있으면 -1 반환 (문제 요구사항)
        return -1;
    else // 스택이 비어있지 않은 경우
    {
        // 삭제될 노드(현재 top 노드)를 가리키는 임시 포인터 설정
        StackNode *temp = s->top;
        // 반환할 데이터를 미리 저장
        element data = temp->data;
        // top 포인터를 다음 노드로 이동시켜 스택의 top을 업데이트
        s->top = s->top->link;
        // 제거된 노드의 메모리를 해제
        free(temp);
        // 저장해두었던 데이터를 반환
        return data;
    }
}

// 스택의 모든 요소를 출력하는 함수
void print_stack(LinkedStackType *s)
{
    // top부터 시작하여 link를 따라가며 각 노드의 데이터 출력
    for (StackNode *p = s->top; p != NULL; p = p->link)
        printf("%d->", p->data); // "데이터->" 형식으로 출력
    printf("NULL \n"); // 마지막에 "NULL"과 개행 문자 출력
}

// 메인 함수
int main(void)
{
    LinkedStackType s; // 연결 스택 타입 변수 선언
    int n, num; // 명령 수(n), push할 숫자(num) 변수 선언
    init(&s); // 스택 초기화
    char c[10]; // 명령어를 입력받을 문자열 배열

    scanf("%d", &n); // 명령의 수 입력 받기
    // n번 반복하며 명령어 처리
    for (int i = 0; i < n; i++)
    {
        scanf("%s", c); // 명령어 문자열 입력 받기

        // 입력받은 명령어가 "push"인 경우
        if (strcmp(c, "push") == 0)
        {
            scanf("%d", &num); // push할 정수 입력 받기
            push(&s, num); // push 함수 호출
        }
        // 입력받은 명령어가 "pop"인 경우
        else if (strcmp(c, "pop") == 0)
        {
            printf("%d\n", pop(&s)); // pop 함수 호출 및 결과 출력
        }
        // 그 외의 명령어는 오류 처리
        else
             printf("error\n"); // 잘못된 명령어 입력 시 에러 메시지 출력

    }
    // 모든 명령 처리 후 스택의 상태 정보 출력
    printf("size : %d\n", size(&s)); // 현재 스택의 크기 출력
    printf("is_empty : %d\n", is_empty(&s)); // 스택이 비었는지 여부 출력 (1: 비었음, 0: 안 비었음)
    printf("peek : %d\n", peek(&s)); // 스택의 맨 위 데이터 확인 (비었으면 -1)
    print_stack(&s); // 현재 스택의 모든 요소 출력
    return 0; // 프로그램 정상 종료
}
