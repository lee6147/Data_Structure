#include <stdio.h>
#include <stdlib.h>

#define MAX_VERTICES 256 // 정점(도시)은 최대 256개까지만 만들게요.

// [연결 리스트의 노드]
// 각 정점(도시)에서 갈 수 있는 '다음 도시 정보'를 담은 쪽지라고 생각하세요.
typedef struct ListNode {
    int vertex;            // 연결된 정점의 번호 (목적지 도시 번호)
    struct ListNode* link; // 다음 쪽지를 가리키는 밧줄 (다음 연결 정보)
} ListNode;

// [그래프 구조체]
// 그래프 전체를 관리하는 '지도 대장'입니다.
typedef struct GraphType {
    int n;                            // 현재 정점(도시)이 몇 개 있는지 카운트
    char vertex_label[MAX_VERTICES];  // 정점의 실제 이름들 (A, B, C...)
    ListNode* adj_list[MAX_VERTICES]; // 각 정점마다 연결된 '이웃 리스트'의 시작점
} GraphType;

//==================================================
// 그래프 관련 함수들
//==================================================

// 그래프가 텅 비었는지 확인해요.
int is_empty(GraphType* g) { 
    return (g->n == 0); 
}

// 그래프가 꽉 찼는지 확인해요.
int is_full(GraphType* g) { 
    return (g->n >= MAX_VERTICES); 
}

// [1. 그래프 초기화]
// 지도를 처음 펼칠 때, 아무것도 없는 깨끗한 상태로 만드는 작업이에요.
void init_graph(GraphType* g) {
    /* [ 구현 부분 시작 ] */
    g->n = 0; // 도시 개수는 0개부터 시작!
    
    // 모든 정점의 '이웃 리스트'를 비워둡니다. (NULL은 '아무것도 없음'을 뜻해요)
    for (int i = 0; i < MAX_VERTICES; i++) {
        g->adj_list[i] = NULL;
    }
    /* [ 구현 부분 끝 ] */
}

// [2. 메모리 해제]
// 다 쓴 지도는 정리해야죠! 빌려 썼던 메모리 공간을 컴퓨터에게 반납합니다.
void free_graph(GraphType* g) {
    /* [ 구현 부분 시작 ] */
    // 등록된 모든 정점(도시)을 하나씩 돌면서 정리해요.
    for (int i = 0; i < g->n; i++) {
        ListNode* p = g->adj_list[i]; // i번 도시의 이웃 목록을 가져와요.
        
        // 이웃 목록이 끝날 때까지 하나씩 지워나갑니다.
        while (p != NULL) {
            ListNode* temp = p; // 현재 쪽지를 잠깐 잡아두고,
            p = p->link;        // 다음 쪽지로 이동한 뒤,
            free(temp);         // 잡아둔 쪽지를 반납(삭제)해요.
        }
    }
    /* [ 구현 부분 끝 ] */
}

// [3. 정점(도시) 추가]
// 지도에 새로운 도시(이름)를 하나 등록하는 과정이에요.
void insert_vertex(GraphType* g, char v_label) {
    /* [ 구현 부분 시작 ] */
    // 지도가 꽉 찼으면 더 이상 추가할 수 없어요.
    if (is_full(g)) {
        return;
    }
    // 현재 순서(n)에 도시 이름(v_label)을 기록하고,
    g->vertex_label[g->n] = v_label;
    // 도시 개수(n)를 1개 늘려줍니다.
    g->n++;
    /* [ 구현 부분 끝 ] */
}

// [4. 간선(길) 추가]
// 'from' 도시에서 'to' 도시로 가는 길을 만들어요.
// **중요**: 리스트의 '맨 앞'에 새 정보를 끼워 넣는 방식입니다.
void insert_edge(GraphType* g, int from, int to) {
    /* [ 구현 부분 시작 ] */
    // 1. 새로운 쪽지(노드)를 하나 만들어요. (메모리 빌리기)
    ListNode* node = (ListNode*)malloc(sizeof(ListNode));
    
    // 2. 이 쪽지에 목적지(to)를 적습니다.
    node->vertex = to;
    
    // 3. 새 쪽지의 밧줄(link)을 원래 맨 앞에 있던 쪽지와 연결해요.
    //    (새치기하듯이 맨 앞에 서는 거예요!)
    node->link = g->adj_list[from];
    
    // 4. 이제 이 새 쪽지가 'from' 도시 리스트의 '첫 번째'가 됩니다.
    g->adj_list[from] = node;
    /* [ 구현 부분 끝 ] */
}

// [입력 받아서 그래프 만들기]
// 문제에서 주는 입력을 받아서 실제 그래프를 완성하는 함수입니다.
void build_graph(GraphType* g) {
    int n;
    scanf("%d", &n); // 전체 도시 개수 입력
    
    char v_label;
    int curr_v, to_v, is_connected;
    
    // 도시 개수만큼 반복하며 정보를 입력받아요.
    for (curr_v = 0; curr_v < n; curr_v++) {
        scanf(" %c", &v_label); // 도시 이름(A, B...) 입력
        insert_vertex(g, v_label); // 도시 등록
        
        // 현재 도시(curr_v)에서 다른 도시들로 가는 연결 정보(0 or 1) 입력
        for (to_v = 0; to_v < n; to_v++) {
            scanf(" %d", &is_connected);
            
            // 1이면 연결된 것이므로 길(간선)을 추가해요.
            if (is_connected) insert_edge(g, curr_v, to_v);
        }
    }
}

//==================================================
// DFS 관련 함수들
//==================================================

int visited[MAX_VERTICES]; // 방문 도장 찍을 곳 (0: 안감, 1: 갔음)

// 방문 기록을 모두 0으로 초기화해요.
void init_visited(GraphType* g) {
    for (int i = 0; i < g->n; i++)
        visited[i] = 0;
}

// [5. 깊이 우선 탐색 (DFS)]
// 한 놈만 팬다! 갈 수 있는 데까지 깊게 들어갔다가, 막히면 돌아오는 탐색법입니다.
void DFS(GraphType* g, int v) {
    /* [ 구현 부분 시작 ] */
    ListNode* w;
    
    // 1. 일단 현재 도시(v)에 도착했으니 '방문 도장'을 꾹 찍어요! (visited = 1)
    visited[v] = 1;
    
    // 2. 도착한 도시의 이름을 화면에 출력해요.
    printf("%c ", g->vertex_label[v]);
    
    // 3. 현재 도시(v)와 연결된 이웃 도시들을 하나씩 살펴봐요.
    //    g->adj_list[v] (첫 번째 이웃)부터 시작해서 밧줄(link)을 타고 끝까지 갑니다.
    for (w = g->adj_list[v]; w; w = w->link) {
        
        // 4. 만약 그 이웃 도시(w->vertex)가 아직 방문하지 않은 곳(!visited)이라면?
        if (!visited[w->vertex]) {
            // 5. 그 도시로 이동해서 탐색을 계속해요! (재귀 호출: 자기 자신을 또 부름)
            DFS(g, w->vertex);
        }
    }
    /* [ 구현 부분 끝 ] */
}

//==================================================
// 메인 함수
//==================================================

int main() {
    GraphType* g;
    // 그래프 대장(GraphType)을 위한 공간을 하나 빌립니다.
    g = (GraphType*)malloc(sizeof(GraphType));
    
    init_graph(g);   // 그래프 준비!
    build_graph(g);  // 입력값으로 지도 그리기!
    
    init_visited(g); // 방문 기록판 지우개로 싹 지우기
    printf("DFS: ");
    DFS(g, 0);       // 0번 도시(첫 번째 도시)부터 탐색 시작!
    
    free_graph(g);   // 다 썼으니 정리하고 끝내기
    
    return 0;
}