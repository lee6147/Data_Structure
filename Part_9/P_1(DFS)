#include <stdio.h>
#include <stdlib.h>
#define MAX_VERTICES 256

typedef struct GraphType {
    int n;                      // 정점의 개수
    char vertex_label[MAX_VERTICES];  // 정점의 이름
    int adj_mat[MAX_VERTICES][MAX_VERTICES];
} GraphType;

//==================================================
// 그래프 관련 함수들
//==================================================

int is_empty(GraphType* g) { 
    return (g->n == 0); 
}

int is_full(GraphType* g) { 
    return (g->n >= MAX_VERTICES); 
}

// [TODO 함수 1] 그래프 초기화 함수
void init_graph(GraphType* g) {
    // PDF 10장의 'init' 함수 로직을 따릅니다. [cite: 430-438]
    
    int r, c;
    
    // ✅ STEP 1: 정점 개수를 0으로 초기화
    // 처음에는 그래프에 아무 정점도 없는 상태로 시작
    g->n = 0; // [cite: 434]
    
    // ✅ STEP 2: 인접 행렬을 모두 0으로 초기화
    // 인접 행렬은 정점 간의 연결 관계를 표현하는 2차원 배열
    // adj_mat[i][j] = 1이면 정점 i와 j가 연결되어 있다는 뜻
    // adj_mat[i][j] = 0이면 정점 i와 j가 연결되어 있지 않다는 뜻
    // 처음에는 모든 정점이 서로 연결되지 않은 상태로 시작
    for (r = 0; r < MAX_VERTICES; r++)
        for (c = 0; c < MAX_VERTICES; c++)
            g->adj_mat[r][c] = 0; // [cite: 437]
}

// [TODO 함수 2] 정점 삽입 함수
void insert_vertex(GraphType* g, char vertex_label) {
    // PDF 10장의 'insert_vertex' 함수 로직을 따릅니다. [cite: 442-448]
    
    // ✅ STEP 1: 정점 개수가 최대치를 넘는지 안전성 검사
    // 배열 크기가 256이므로, 256개 이상의 정점은 추가할 수 없음
    if (((g->n) + 1) > MAX_VERTICES) {
        fprintf(stderr, "그래프: 정점의 개수 초과"); // [cite: 446]
        return; // 함수를 종료하고 빠져나감
    }
    
    // ✅ STEP 2: 정점의 이름(레이블)을 배열에 저장
    // 예: A, B, C, D, ... 와 같은 정점 이름을 순서대로 저장
    // g->n은 현재 정점 개수이므로, 다음 빈 자리의 인덱스가 됨
    // 예: 정점이 0개면 인덱스 0에 저장, 정점이 1개면 인덱스 1에 저장
    g->vertex_label[g->n] = vertex_label;
    
    // ✅ STEP 3: 정점 개수를 1 증가
    // 정점을 하나 추가했으므로 개수를 업데이트
    g->n++;
}

// [TODO 함수 3] 간선 삽입 함수
void insert_edge(GraphType* g, int from, int to) {
    // PDF 10장의 'insert_edge' 함수 로직을 따릅니다. [cite: 449-458]
    
    // ✅ STEP 1: 정점 번호가 유효한 범위 내에 있는지 검사
    // 정점 번호는 0부터 (n-1)까지만 유효함
    // 예: 정점이 8개면 유효한 인덱스는 0~7
    if (from >= g->n || to >= g->n) { // [cite: 452]
        fprintf(stderr, "그래프: 정점 번호 오류"); // [cite: 453]
        return; // [cite: 454]
    }
    
    // ✅ STEP 2: 인접 행렬에 간선 정보 표시
    // 이 문제는 "무방향 그래프"이므로, 양쪽 모두에 연결 정보를 저장해야 함
    // 
    // 무방향 그래프란?
    // - A와 B가 연결되어 있으면, B와 A도 연결되어 있다는 뜻
    // - 도로를 생각하면 쉬움: A에서 B로 갈 수 있으면, B에서 A로도 갈 수 있음
    //
    // 방향 그래프였다면?
    // - 일방통행 도로처럼, A→B는 가능하지만 B→A는 불가능할 수 있음
    // - 이 경우에는 한 쪽만 1로 표시하면 됨
    g->adj_mat[from][to] = 1; // from 정점에서 to 정점으로의 연결
    g->adj_mat[to][from] = 1; // to 정점에서 from 정점으로의 연결 (무방향이므로 양방향)
}

void build_graph(GraphType* g) {
    // 정점의 개수 입력
    int n;
    scanf("%d", &n);
    
    // 정점의 개수만큼 반복
    char vertex_label;
    int curr_v, to_v, is_connected;
    for (curr_v = 0; curr_v < n; curr_v++) {
        scanf(" %c", &vertex_label);
        insert_vertex(g, vertex_label);

        // 각 정점에 대한 연결 정보 입력
        for (to_v = 0; to_v < n; to_v++) {
            scanf(" %d", &is_connected);

            if (is_connected) insert_edge(g, curr_v, to_v);
        }
    }
}

//==================================================
// DFS 관련 함수들
//==================================================

int visited[MAX_VERTICES];

void init_visited(GraphType* g) {
    for (int i = 0; i < g->n; i++)
        visited[i] = 0;
}

// [TODO 함수 4] DFS(깊이 우선 탐색) 재귀 함수
void DFS(GraphType* g, int v) {
    // PDF 10장의 'dfs_mat' 함수 로직을 따릅니다. [cite: 582-594]
    
    int w;
    
    // ✅ STEP 1: 현재 정점을 "방문했음"으로 표시
    // visited 배열은 각 정점의 방문 여부를 기록
    // visited[v] = 1이면 정점 v를 이미 방문했다는 뜻
    // visited[v] = 0이면 정점 v를 아직 방문하지 않았다는 뜻
    // 같은 정점을 두 번 방문하지 않도록 하기 위해 필요함
    visited[v] = 1;
    
    // ✅ STEP 2: 현재 정점의 이름을 출력
    // DFS의 방문 순서를 확인하기 위해 정점 이름을 출력
    // 예: "A B D C E G H F" 형태로 출력됨
    printf(" %c", g->vertex_label[v]);
    
    // ✅ STEP 3: 현재 정점(v)과 연결된 모든 정점을 탐색
    // DFS(깊이 우선 탐색)의 핵심 로직
    //
    // DFS란?
    // - 한 길을 끝까지 가보고, 막히면 다시 돌아와서 다른 길로 가는 방식
    // - 미로 탐험을 생각하면 쉬움:
    //   1) 갈림길에서 하나를 선택해 끝까지 가봄
    //   2) 막히면 다시 갈림길로 돌아옴
    //   3) 다른 길을 선택해 끝까지 가봄
    //   4) 모든 길을 다 가볼 때까지 반복
    //
    // 재귀 함수로 구현하는 이유?
    // - 재귀는 자연스럽게 "갔던 길로 되돌아오기"를 자동으로 처리해줌
    // - 함수가 끝나면 자동으로 이전 호출 지점으로 돌아가기 때문
    for (w = 0; w < g->n; w++) {
        // 조건 1: adj_mat[v][w] == 1
        //   → 정점 v와 정점 w가 간선으로 연결되어 있는지 확인
        //
        // 조건 2: !visited[w] (visited[w] == 0)
        //   → 정점 w를 아직 방문하지 않았는지 확인
        //   → 이미 방문한 정점은 다시 방문하지 않음 (무한 루프 방지)
        //
        // 두 조건을 모두 만족하면:
        //   → 정점 w로 이동해서 DFS를 계속 진행 (재귀 호출)
        if (g->adj_mat[v][w] && !visited[w]) {
            DFS(g, w); // 재귀 호출: 정점 w에서 다시 DFS 시작
            // 이 줄로 돌아올 때는 w와 연결된 모든 정점을 이미 탐색한 상태
        }
    }
    // 반복문이 끝나면:
    // - 정점 v와 연결된 모든 미방문 정점을 다 탐색했다는 뜻
    // - 함수가 종료되고 이 함수를 호출한 곳으로 돌아감 (백트래킹)
}

//==================================================

int main() {
    GraphType* g;
    g = (GraphType*)malloc(sizeof(GraphType));
    
    init_graph(g);
    build_graph(g);
    
    init_visited(g);
    printf("DFS:");
    DFS(g, 0);
    
    free(g);
    
    return 0;
}
