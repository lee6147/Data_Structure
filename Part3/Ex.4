#include <stdio.h>
#include <stdlib.h>

// 행렬의 한 원소의 정보를 표현하는 구조체
typedef struct {
    int row;    // 행 인덱스
    int col;    // 열 인덱스
    int value;  // 해당 위치의 값
} Term;

// 희소행렬을 표현하는 구조체
typedef struct {
    int rows;    // 행렬 크기 n
    int terms;   // 비제로 항 개수
    Term *data;  // 비제로 항 배열
} SparseMatrix;

/**
 * @brief 힙 메모리에 n×n 행렬을 0으로 초기화한 뒤 비제로 항만 채워 출력
 */
void print_matrix(const SparseMatrix *a) {
    int n = a->rows;
    int *mat = malloc(n * n * sizeof(int));
    if (!mat) {
        perror("메모리 할당 실패");
        return;
    }

    // 1) 0으로 초기화
    for (int i = 0; i < n * n; i++) {
        mat[i] = 0;
    }

    // 2) 비제로 항만 채워넣기
    for (int k = 0; k < a->terms; k++) {
        int r = a->data[k].row;
        int c = a->data[k].col;
        mat[r * n + c] = a->data[k].value;
    }

    // 3) 한 번에 출력
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            printf("%3d", mat[i * n + j]);
        }
        putchar('\n');
    }
    putchar('\n');

    free(mat);
}

// 희소 행렬(a)을 전치시켜 새로운 희소 행렬(t)을 반환하는 함수
SparseMatrix transpose(const SparseMatrix *a) {
    // 1. 전치 행렬을 저장할 변수 t를 선언합니다.
    SparseMatrix t;

    // 2. 전치 행렬의 기본 정보를 설정합니다.
    // 전치 행렬의 행 개수는 원본 행렬의 '열' 개수와 같아야 합니다. (t.rows = a->cols)
    // 이 코드에서는 행 개수를 그대로 복사하고 있으나, 완전한 전치 구현을 위해서는 수정이 필요할 수 있습니다.
    t.rows = a->rows;
    // 전치 행렬의 열 개수는 원본 행렬의 '행' 개수와 같아야 합니다. (t.cols = a->rows)

    // 전치를 해도 0이 아닌 항의 개수는 변하지 않습니다.
    t.terms = a->terms;

    // 3. (★★★ 핵심: 동적 할당 ★★★)
    // 전치 행렬의 0이 아닌 항들을 저장할 공간을 메모리에 동적으로 할당합니다.
    // 필요한 메모리 크기 = (항 1개의 크기) * (총 항의 개수)
    // a->terms가 10이고 Term 구조체 크기가 12바이트라면, 총 120바이트를 할당합니다.
    t.data = malloc(a->terms * sizeof(Term));

    // 4. 메모리 할당 성공 여부를 확인합니다.
    // 만약 malloc이 메모리 할당에 실패하면 NULL을 반환합니다.
    if (!t.data) {
        // 에러 메시지를 출력하고 프로그램을 강제 종료하여 더 큰 문제를 방지합니다.
        printf("메모리 할당에 실패했습니다. 프로그램을 종료합니다.");
        exit(1);
    }

    // 5. 모든 0이 아닌 항에 대해 전치 연산을 수행합니다.
    // 원본 행렬의 항 개수만큼 반복합니다.
    for (int i = 0; i < a->terms; i++) {
        // 전치 연산의 핵심: 행(row)과 열(col)의 값을 서로 바꿉니다.
        // 전치 행렬 항의 '행' = 원본 행렬 항의 '열'
        t.data[i].row = a->data[i].col;
        // 전치 행렬 항의 '열' = 원본 행렬 항의 '행'
        t.data[i].col = a->data[i].row;
        // 값(value)은 그대로 복사합니다.
        t.data[i].value = a->data[i].value;
    }
    
    // 참고: 이 구현은 항들을 순서대로 정렬하지는 않습니다.
    // 정렬된 결과가 필요하다면 추가적인 정렬 로직이 필요합니다.

    // 6. 완성된 전치 행렬 t를 반환합니다.
    return t;
}


int main(void) {
    int n, num;
    if (scanf("%d %d", &n, &num) != 2) {
        fprintf(stderr, "입력 오류\n");
        return 1;
    }

    SparseMatrix M;
    M.rows  = n;
    M.terms = num;
    M.data  = malloc(num * sizeof(Term));
    if (!M.data) {
        perror("메모리 할당 실패");
        return 1;
    }

    for (int i = 0; i < num; i++) {
        if (scanf("%d %d %d",
                  &M.data[i].row,
                  &M.data[i].col,
                  &M.data[i].value) != 3) {
            fprintf(stderr, "입력 형식 오류\n");
            free(M.data);
            return 1;
        }
    }

    // 1) 원본 출력
    print_matrix(&M);

    // 2) 전치 생성 및 출력
    SparseMatrix T = transpose(&M);
    print_matrix(&T);

    // 해제
    free(M.data);
    free(T.data);
    return 0;
}
